#' Helper function to create highest/lowest ten tables in markdown report.
#'
#' @description
#' Takes a named vector containing values (e.g. subjects) and counts,
#' sorts by number of counts, takes the top ten, and returns a data.frame
#'
#' @details
#' This is a helper function used to grab the highest or lowest ten values
#' to print as a table in the markdown report.
#'
#' @param decreasing logical, passed to sort to control increasing or decreasing order
#' @param vec named vector, containing values and counts
#' @param column.label string, name of first column (e.g. Subjects, Variables)
#' @return data.frame with ten rows containing values and counts
get.top.ten <- function(decreasing, vec, column.label) {
  ten.df <- data.frame(c(), c())
  if (length(vec) > 0) {
    vec.sorted <- sort(vec, decreasing = decreasing)[seq_len(min(10, length(vec)))]
    ten.df <- data.frame(names(vec.sorted), vec.sorted)
    colnames(ten.df) <- c(column.label, "Counts")
    rownames(ten.df) <- NULL
  }
  ten.df
}


#' Make sure the number of bins in a histogram isn't too close to the
#' number of unique values!
#'
#' @param vec numeric vector; input data to histogram
get.bins <- function(vec) {
  n.unique.values <- length(unique(vec))
  if (n.unique.values > 50) {
    50
  } else {
    n.unique.values
  }
}


#' Helper function to conditionally print output content
#'
#' If the passed value is null, no action is taken; otherwise,
#' the thing is emitted wrapped in a print() or cat() statement
#'
#' @param val thing to be conditionally printed
print.conditionally <- function(val) {
  if (!is.null(val)) {
    if (inherits(val, "knitr_kable")) {
      cat(val)
    } else {
      print(val)
    }
  }
}

#' Helper function to emit formatted markdown header summarizing
#' data cleaning process
#'
#' @param dataset.yaml character; name of input dataset yaml file
#' @param total.initial.sample.size numeric; number of lines in initial input file
#' @param consent.inclusion.file character or NULL; name of input file containing
#' consent approved subject list, or NULL
#' @param subjects.consent.yes numeric; if consent.inclusion.file is not
#' NULL, the number of subjects in the input dataset that were present in the
#' input consent approved subject list
#' @param consent.exclusion.file character or NULL; name of input file containing
#' consent rejected subject list, or NULL
#' @param subjects.consent.no numeric; if consent.exclusion.file is not
#' NULL, the number of subjects in the input dataset that were present in the
#' input consent rejected subject list
#' @param subjects.ambiguous.consent numeric; if consent.inclusion.file and
#' consent.exclusion.file are both not NULL, the number of subjects in the
#' input dataset that were absent from both consent lists
#' @param subjects.excluded.for.age numeric; number of subjects with reported
#' age less than the minimum value specified in dataset yaml/globals/min_age_for_inclusion
#' @param min.age.for.inclusion numeric; entry from dataset yaml/globals/min_age_for_inclusion
#' @param na.subject.id.count numeric; number of subjects with invalid subject ID entries
#' @return character; formatted header content
emit.markdown.header <- function(dataset.yaml,
                                 total.initial.sample.size,
                                 consent.inclusion.file,
                                 subjects.consent.yes,
                                 consent.exclusion.file,
                                 subjects.consent.no,
                                 subjects.ambiguous.consent,
                                 subjects.excluded.for.age,
                                 min.age.for.inclusion,
                                 na.subject.id.count) {
  out.msg <- paste("This report and the accompanying cleaned data is generated by the code available ",
    "at <a href=\"https://gitlab.com/data-analysis5/process.phenotypes\">this</a> repository, ",
    "run using the configuration outlined in ", dataset.yaml, ".\n<br><br>\n",
    "The report is a summary of the phenotype data and includes subject-level summary metrics, ",
    "variable-level summary metrics, a linker between original variable names and standardized encoded names, ",
    "and per-variable summaries.  The per-variable summaries vary based on data type.  Numeric types will ",
    "display a histogram and min/max/mean/median/deciles.  Categorical and ordinal types display counts of each ",
    "factor level.  All types other than string include a summary of data entries that are not consistent with ",
    "the indicated data type.  Dependencies, bounds, data types, etc. are defined in the accompanying configuration ",
    "file.\n\n",
    "Please note that with few exceptions, the original variable names and descriptions in this report are read ",
    "verbatim from the input data, and have not been edited, to maintain harmonization with the original ",
    "questionnaire definitions.\n\n",
    total.initial.sample.size, ifelse(total.initial.sample.size == 1, " subject was", " subjects were"),
    " originally present in this dataset.",
    ifelse(!is.null(consent.inclusion.file),
      paste(" ", subjects.consent.yes,
        ifelse(subjects.consent.yes == 1,
          " subject was",
          " subjects were"
        ),
        " included with verified consent.",
        sep = ""
      ),
      ""
    ),
    ifelse(!is.null(consent.exclusion.file),
      paste(" ",
        subjects.consent.no,
        ifelse(subjects.consent.no == 1,
          " subject was",
          " subjects were"
        ),
        " excluded for lacking consent.",
        sep = ""
      ),
      ""
    ),
    ifelse(!is.null(consent.inclusion.file) & !is.null(consent.exclusion.file),
      paste(" ",
        length(subjects.ambiguous.consent),
        ifelse(length(subjects.ambiguous.consent) == 1,
          " subject was",
          " subjects were"
        ),
        " additionally excluded for not being explicitly listed as either having or lacking consent.",
        sep = ""
      ),
      ""
    ),
    " ", subjects.excluded.for.age,
    ifelse(subjects.excluded.for.age == 1, " subject was ", " subjects were "),
    "removed for being below the minimum permissible age of ", min.age.for.inclusion, ".",
    "\n\n",
    na.subject.id.count,
    ifelse(na.subject.id.count == 1, " subject was ", " subjects were "),
    "removed for lacking a subject ID.\n\n",
    ifelse(length(subjects.ambiguous.consent) > 0, "***\n<br>", ""),
    sep = ""
  )
  out.msg
}


#' Helper function to report tracking information about variable
#' name and, for derived variables, code creating the variable
#'
#' @param variable.entry list; entry in dataset yaml for this variable
report.name.and.code <- function(variable.entry) {
  if (!is.null(variable.entry$params$canonical_name)) {
    cat(
      "Official variable identity: \"",
      variable.entry$params$canonical_name, "\"", "\n\n",
      sep = ""
    )
  }
  if (!is.null(variable.entry$params$code)) {
    cat(
      "\n\nThe logic to create this derived variable is as follows:\n\n```\n",
      variable.entry$params$code, "\n```\n\n",
      sep = ""
    )
  }
}

#' Helper function to report detected excel problems in variable contents
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
report.excel.problems <- function(variable.entry, suppress.reporting) {
  if (!is.null(variable.entry$excel.problem.count) && !suppress.reporting) {
    if (variable.entry$excel.problem.count == 1) {
      cat("\nWARNING: 1 Excel error code detected in this variable.\n")
    } else {
      cat("\nWARNING: ", variable.entry$excel.problem.count,
        " Excel error codes detected in this variable.\n",
        sep = ""
      )
    }
  }
}

#' Helper function to report summary information about numeric
#' variables' distributions
#'
#' @param data.vec numeric vector; column from phenotype dataframe
#' for this variable
#' @param phenotype.data data.frame; full phenotype data for selection
#' of linked variable contents
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param variable.pretty.name character; human-legible name of
#' variable with more helpful description
#' @param my.theme ggplot2 accumulated theme settings
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return list; 'hist.plot' distribution plot, 'tab.summary'
#' distribution table. either entry can be null based on conditional
#' logic
#' @importFrom graphics hist
report.numeric.summary <- function(data.vec,
                                   phenotype.data,
                                   variable.entry,
                                   name,
                                   variable.pretty.name,
                                   my.theme,
                                   suppress.reporting) {
  hist.plot <- NULL
  tab.summary <- NULL
  if (is.vector(data.vec, mode = "numeric") && !suppress.reporting) {
    if (length(which(!is.na(data.vec)))) {
      ## create data histogram for numeric data
      plot.data <- data.frame(x = data.vec[!is.na(data.vec)])
      if (length(unique(plot.data$x)) > 0) {
        hist.plot <- ggplot2::ggplot(data = plot.data) + my.theme
        nbins <- get.bins(data.vec[!is.na(data.vec)])
        binwidth <- (diff(range(data.vec[!is.na(data.vec)])) + 1) / nbins
        if (!is.null(variable.entry$params$multimodal)) {
          multimodal.varname <- variable.entry$params$multimodal
          stopifnot(multimodal.varname %in% colnames(phenotype.data))
          multimodal.values <- unique(phenotype.data[!is.na(phenotype.data[, multimodal.varname]), multimodal.varname])
          hist.plot.colours <- RColorBrewer::brewer.pal(max(3, length(multimodal.values)), "Dark2")
          hist.plot.colours <- hist.plot.colours[seq_len(length(multimodal.values))]
          annotate.y <- max(hist(data.vec, breaks = nbins, plot = FALSE)$counts) / nrow(phenotype.data)
          for (i in seq_len(length(multimodal.values))) {
            if (length(which(phenotype.data[, multimodal.varname] == multimodal.values[i] &
              !is.na(data.vec))) == 0) {
              next
            }
            plot.subset <- phenotype.data[phenotype.data[, multimodal.varname] == multimodal.values[i] &
              !is.na(data.vec) & !is.na(phenotype.data[, multimodal.varname]), ]
            hist.plot <- hist.plot + ggplot2::geom_histogram(ggplot2::aes_string(
              x = name,
              y = "..count../sum(..count..)"
            ),
            data = plot.subset,
            bins = nbins,
            binwidth = binwidth,
            fill = hist.plot.colours[i],
            alpha = 0.2
            )
            mode.mean <- mean(plot.subset[, name],
              na.rm = TRUE
            )
            hist.plot <- hist.plot + ggplot2::geom_vline(
              xintercept = mode.mean,
              colour = hist.plot.colours[i]
            )
            hist.plot <- hist.plot + ggplot2::annotate("text",
              label = multimodal.values[i],
              x = mode.mean * 1.15,
              y = annotate.y * (1 - (i - 1) * 0.05),
              size = 3,
              hjust = 0,
              colour = hist.plot.colours[i]
            )
          }
        } else {
          hist.plot <- hist.plot + ggplot2::geom_histogram(
            ggplot2::aes_string(x = "x", y = "..count.. / sum(..count..)"),
            bins = nbins,
            binwidth = binwidth
          )
        }
        hist.plot <- hist.plot + ggplot2::xlab(name) + ggplot2::ylab("proportion of data")
        if (is.null(variable.entry$params$bounds$sd)) {
          var.mean <- mean(data.vec, na.rm = TRUE)
          var.sd <- sd(data.vec, na.rm = TRUE)
          if (!is.na(var.sd)) {
            hist.plot <- hist.plot + ggplot2::geom_vline(
              xintercept = var.mean + 3 * var.sd,
              linetype = "dashed"
            )
            hist.plot <- hist.plot + ggplot2::geom_vline(
              xintercept = var.mean - 3 * var.sd,
              linetype = "dashed"
            )
          }
        }
        cat(
          "\n\n#### Histogram of ", name, " (", variable.pretty.name,
          ") Distribution\n\n",
          sep = ""
        )
      }
    }
    if (!is.null(variable.entry$params$bounds)) {
      bound.type <- c()
      bound.value <- c()
      bound.count <- c()
      if (!is.null(variable.entry$params$bounds$min)) {
        bound.type <- c(bound.type, "minimum")
        bound.value <- c(bound.value, variable.entry$params$bounds$min)
        bound.count <- c(bound.count, variable.entry$num.below.min)
      }
      if (!is.null(variable.entry$params$bounds$max)) {
        bound.type <- c(bound.type, "maximum")
        bound.value <- c(bound.value, variable.entry$params$bounds$max)
        bound.count <- c(bound.count, variable.entry$num.above.max)
      }
      if (!is.null(variable.entry$params$bounds$sd)) {
        bound.type <- c(bound.type, "standard deviation")
        bound.value <- c(bound.value, variable.entry$params$bounds$sd)
        bound.count <- c(bound.count, variable.entry$num.beyond.sd)
      }
      bound.df <- data.frame(
        Type = bound.type,
        Value = bound.value,
        Count = bound.count
      )
      rownames(bound.df) <- NULL
      table.caption <- paste("Numeric bounds on ", name, " (", variable.pretty.name, ")", sep = "")
      tab.summary <- knitr::kable(bound.df, caption = table.caption) %>%
        kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
    }
  }
  list(
    hist.plot = hist.plot,
    tab.summary = tab.summary
  )
}


#' Helper function to report relationship between an age variable
#' and its corresponding date
#'
#' @param data.vec numeric vector; column from phenotype dataframe
#' for this age variable
#' @param phenotype.data data.frame; full phenotype data for selection
#' of linked variable contents
#' @param variable.entry list; entry in dataset yaml for this age variable
#' @param name character; harmonized name of variable in yaml
#' @param my.theme ggplot2 accumulated theme settings
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted ggplot for rendering, or nothing if reporting suppressed
report.linked.date <- function(data.vec,
                               phenotype.data,
                               variable.entry,
                               name,
                               my.theme,
                               suppress.reporting) {
  if (!is.null(variable.entry$params$linked_date) && !suppress.reporting) {
    reported.year.varname <- variable.entry$params$linked_date$reported_year
    reference.year <- variable.entry$params$linked_date$reference_year
    stopifnot(
      reported.year.varname %in% colnames(phenotype.data),
      is.numeric(reference.year) |
        (is.character(reference.year) & reference.year %in% colnames(phenotype.data))
    )
    reported.year <- phenotype.data[, reported.year.varname]
    if (is.character(reference.year)) {
      reference.year <- phenotype.data[, reference.year]
    }
    reported.age <- data.vec
    derived.age <- reference.year - reported.year
    plot.data <- data.frame(
      x = reported.age,
      y = derived.age
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    age.plot <- ggplot2::ggplot(ggplot2::aes_string(x = "x", y = "y"), data = plot.data) + my.theme
    age.plot <- age.plot + ggplot2::geom_point() + ggplot2::geom_abline(slope = 1, intercept = 0)
    age.plot <- age.plot + ggplot2::xlab("Reported Age") + ggplot2::ylab("Age Computed from Date")
    cat("\n\n#### Comparison between reported age ", name, " and age derived from date ",
      reported.year.varname, "\n\n",
      sep = ""
    )
    age.plot
  }
}

#' Helper function to report summary information about reported BMI
#' and computed BMI directly from weight and height data
#'
#' @param phenotype.data data.frame; full phenotype data for variable
#' selection
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param my.theme ggplot2 accumulated theme settings
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted ggplot for rendering, or nothing if reporting suppressed
report.bmi.comparison <- function(phenotype.data,
                                  variable.entry,
                                  name,
                                  my.theme,
                                  suppress.reporting) {
  if (!is.null(variable.entry$params$computed_bmi) && !suppress.reporting) {
    height.varname <- variable.entry$params$computed_bmi$height
    weight.varname <- variable.entry$params$computed_bmi$weight
    stopifnot(
      height.varname %in% colnames(phenotype.data),
      weight.varname %in% colnames(phenotype.data)
    )
    reported.bmi <- phenotype.data[, name]
    height.var <- phenotype.data[, height.varname]
    weight.var <- phenotype.data[, weight.varname]
    computed.bmi <- weight.var / height.var^2
    plot.data <- data.frame(
      x = reported.bmi,
      y = computed.bmi
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    bmi.plot <- ggplot2::ggplot(ggplot2::aes_string(x = "x", y = "y"), data = plot.data) + my.theme
    bmi.plot <- bmi.plot + ggplot2::geom_point() + ggplot2::geom_abline(slope = 1, intercept = 0)
    bmi.plot <- bmi.plot + ggplot2::xlab("Reported BMI") + ggplot2::ylab("BMI Computed from Height/Weight")
    cat("\n\n#### Comparison between reported BMI ", name,
      " and BMI derived from height ", height.varname,
      " and weight ", weight.varname, "\n\n",
      sep = ""
    )
    bmi.plot
  }
}


#' Helper function to report plot showing relationship between
#' self-reported systolic and diastolic blood pressure
#'
#' @param phenotype.data data.frame; full phenotype data for variable
#' selection
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param my.theme ggplot2 accumulated theme settings
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted ggplot for rendering, or nothing if reporting suppressed
report.bp.ratio <- function(phenotype.data,
                            variable.entry,
                            name,
                            my.theme,
                            suppress.reporting) {
  if (!is.null(variable.entry$params$computed_bp_ratio) && !suppress.reporting) {
    systolic.bp <- phenotype.data[, name]
    diastolic.bp.varname <- variable.entry$params$computed_bp_ratio$diastolic
    stopifnot(diastolic.bp.varname %in% colnames(phenotype.data))
    diastolic.bp <- phenotype.data[, diastolic.bp.varname]
    plot.data <- data.frame(x = systolic.bp, y = diastolic.bp)
    bp.plot <- ggplot2::ggplot(ggplot2::aes_string(x = "x", y = "y"), data = plot.data) + my.theme
    bp.plot <- bp.plot + ggplot2::geom_point() + ggplot2::geom_abline(slope = 1, intercept = 0)
    bp.plot <- bp.plot + ggplot2::xlab("Reported systolic BP") + ggplot2::ylab("Reported diastolic BP")
    cat("\n\n#### Comparison between reported systolic ", name,
      " and diastolic blood pressure ", diastolic.bp.varname, "\n\n",
      sep = ""
    )
    bp.plot
  }
}


#' Helper function to report information about observed entries
#' in text-like variables
#'
#' @param phenotype.data data.frame; full phenotype data for variable
#' selection
#' @param var.summary table; contingency data about observations
#' of values in variable
#' @param unique.var.value.inc.prop numeric; the proportion threshold
#' above which variables with too many unique values will not have
#' their value contingency data reported
#' @param name character; harmonized name of variable in yaml
#' @param variable.pretty.name character; human-legible name of
#' variable with more helpful description
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.content.summary <- function(phenotype.data,
                                   var.summary,
                                   unique.var.value.inc.prop,
                                   name,
                                   variable.pretty.name,
                                   suppress.reporting) {
  if ((is.vector(phenotype.data[, name], mode = "numeric") && !suppress.reporting) ||
    ((is.factor(phenotype.data[, name]) ||
      length(var.summary) < nrow(phenotype.data) * unique.var.value.inc.prop) && !suppress.reporting)) {
    variable.summary.df <- data.frame(
      names(var.summary), as.vector(var.summary)
    )
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([0-9]+)\\. ", "\\1\\2\\\\. ")
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^-$", "--")
    rownames(variable.summary.df) <- NULL
    colnames(variable.summary.df) <- c("Value", "Summary statistics")
    table.caption <- paste("Summary of ", name, " (", variable.pretty.name, ")", sep = "")
    knitr::kable(variable.summary.df, caption = table.caption) %>%
      kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
  } else if (length(var.summary) >= nrow(phenotype.data) * unique.var.value.inc.prop && !suppress.reporting) {
    cat("\n\nVariable ", name, " (", variable.pretty.name, ") has ", length(var.summary), " unique values, and thus",
      " report output of individual value counts is suppressed.\n\n",
      sep = ""
    )
  } else if (suppress.reporting) {
    cat("\n\nReporting for variable", name, "was suppressed in the configuration.\n\n")
  }
}


#' Helper function to report information about blood pressure
#' variable entries that do not match expected blood pressure
#' systolic/diastolic reporting format.
#'
#' @details Many instances of non-compliant blood pressure reporting
#' formats have been observed in various test datasets. This reporting
#' information is intended both to record non-compliant data and to
#' suggest new, "creative" formats that might be supported in patches
#' to this package
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.noncompliant.bp <- function(variable.entry,
                                   name,
                                   suppress.reporting) {
  if (!is.null(variable.entry$invalid.blood.pressure.entries) && !suppress.reporting) {
    if (length(variable.entry$invalid.blood.pressure.entries) > 0) {
      df <- data.frame(table(variable.entry$invalid.blood.pressure.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      knitr::kable(df, caption = "Values that were not consistent with blood pressure measurement format.") %>%
        kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
    } else {
      cat("\n\nAll values consistent with blood pressure format or missing data.\n\n")
    }
  }
}

#' Helper function to report information about entries in
#' expected-numeric variables that do not match supported
#' numeric format.
#'
#' @details substantial processing is applied to string representations
#' of input data before numeric conversion is attempted. this report
#' covers entries that fail conversion after such string cleaning
#' is attempted.
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.noncompliant.numerics <- function(variable.entry,
                                         name,
                                         suppress.reporting) {
  if (!is.null(variable.entry$invalid.numeric.entries) && !suppress.reporting) {
    if (length(variable.entry$invalid.numeric.entries) > 0) {
      df <- data.frame(table(variable.entry$invalid.numeric.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      knitr::kable(df, caption = "Values that were not consistent with numeric format.") %>%
        kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
    } else {
      cat("\n\nAll values consistent with numeric format or missing data.\n\n")
    }
  }
}


#' Helper function to report summary information about uncertain
#' values in expected categorical variables.
#'
#' @details this function has hybrid functionality. it was originally
#' intended to report entries of factor variables that do not match
#' defined levels/shared model data. later on, functionality was added
#' to try to ad hoc harmonize self-reported ancestry labels, and at
#' that point this function was expanded to provide a detailed summary
#' of resolution status for such ancestry variables as well.
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.factor.summary <- function(variable.entry,
                                  name,
                                  suppress.reporting) {
  ## give ancestry factor variable special treatment
  if (!is.null(variable.entry$params$subject_ancestry) &&
    length(variable.entry$ancestry.reasoning) > 0 &&
    !suppress.reporting) {
    ## instead of reporting failed conversions specifically,
    ## report a table of all imperfect matches to the reference ancestry labels,
    ## and track the outcomes for all of them, even the ones that were eventually
    ## called. this behavior may be updated later once this method has been
    ## improved
    df <- data.frame(
      variable.entry$ancestry.conversion.before,
      variable.entry$ancestry.conversion.after,
      variable.entry$ancestry.reasoning,
      variable.entry$ancestry.best.match,
      round(variable.entry$ancestry.best.value, 2),
      variable.entry$ancestry.second.match,
      round(variable.entry$ancestry.second.value, 2)
    )
    colnames(df) <- c(
      "Input",
      "Output",
      "Reasoning",
      "Best Match",
      "Best Score",
      "Second Match",
      "Second Score"
    )
    df$Count <- rep(0, nrow(df))
    for (query in unique(df[, 1])) {
      df$Count[df[, 1] == query] <- length(which(df[, 1] == query))
    }

    ## clean up table: for large datasets, this gets unwieldy
    ## first remove duplicate queries, as the resolution is always the same
    df <- df[!duplicated(df[, 1]), ]
    ## then sort first by reasoning, then by output, then by query
    df <- df[order(df[, 3], df[, 2], df[, 1]), ]
    rownames(df) <- NULL
    knitr::kable(df, caption = "Handling of all partial match self-reported ancestries.") %>%
      kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
  } else if (!is.null(variable.entry$invalid.factor.entries) && !suppress.reporting) {
    ## other things that are factors
    if (length(variable.entry$invalid.factor.entries) > 0) {
      df <- data.frame(table(variable.entry$invalid.factor.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      knitr::kable(df, caption = "Values that were not consistent with categorical format.") %>%
        kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
    } else {
      cat("\n\nAll values consistent with categorical format or missing data.\n\n")
    }
  }
}

#' Helper function to report summary information about values
#' in date variables that do not match expected date formats.
#'
#' @details free-text date variables typically contain a wide variety
#' of input formats. the package heuristically supports a variety of
#' date formats, but still many observed values are ultimately not
#' reasonably convertable to year specifications. this function reports
#' such values, both for reporting purposes and to suggest possible
#' extensions to the supported date format regex (or not).
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param name character; harmonized name of variable in yaml
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.noncompliant.dates <- function(variable.entry,
                                      name,
                                      suppress.reporting) {
  if (!is.null(variable.entry$invalid.date.entries) && !suppress.reporting) {
    if (length(variable.entry$invalid.date.entries) > 0) {
      df <- data.frame(table(variable.entry$invalid.date.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      knitr::kable(df, caption = "Values that were not consistent with date (year only) format.") %>%
        kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
    } else {
      cat("\n\nAll values consistent with date format (year only) or missing data.\n\n")
    }
  }
}

#' Helper function to report summary information about Unicode
#' characters that are not removed by upstream cleaning.
#'
#' @details Unicode characters often sneak by the ad hoc conversion
#' logic used in this package. the linking between Unicode character
#' and desired ASCII representation has been exposed to config space.
#' this reporting function includes tracking information about the
#' observed Unicode character, in the hopes that the user can expand
#' the mapping table to convert such characters into compliant values.
#'
#' @param variable.entry list; entry in dataset yaml for this variable
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return formatted kable for rendering, or nothing if reporting suppressed
report.unicode.entries <- function(variable.entry,
                                   suppress.reporting) {
  if (!is.null(variable.entry$unicode.entries) && !suppress.reporting) {
    unicode.df <- data.frame(
      names(variable.entry$unicode.entries),
      as.vector(variable.entry$unicode.entries)
    )
    rownames(unicode.df) <- NULL
    colnames(unicode.df) <- c("Unicode String", "Observations")
    knitr::kable(unicode.df, caption = "String entries containing unresolved Unicode characters.") %>%
      kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
  }
}

#' Helper function to report summary information about encoded
#' dependency relationships between variables.
#'
#' @details this function handles all reporting of variable dependencies
#' from the input config yaml dependency blocks. currently, the report
#' does not contain direct information about the downstream effects of
#' exclude_on_error or exclude_all_on_error directives. this may
#' be added in future iterations of the report.
#'
#' @param phenotype.data data.frame; full phenotype data for selection
#' of linked variable contents
#' @param variable.summary list; input dataset config yaml
#' @param name character; harmonized name of variable in yaml
#' @param suppress.reporting logical; whether variable report data
#' should be suppressed
#' @return list; entries 'contingency' and 'cross', for kables describing
#' contingency table of results and cross-variable comparisons; or null,
#' if reporting suppressed or the relevant features not configured
report.dependencies <- function(phenotype.data,
                                variable.summary,
                                name,
                                suppress.reporting) {
  result.tables <- list()
  if (!is.null(variable.summary$variables[[name]]$params$dependencies) && !suppress.reporting) {
    cat("\n\n#### Dependency tracking\n\n")
    dependency.names <- c()
    dependency.conditions <- c()
    dependency.results <- c()
    dependencies <- variable.summary$variables[[name]]$params$dependencies
    for (dependency.index in names(dependencies)) {
      dependency.names <- c(dependency.names, dependencies[[dependency.index]]$name)
      dependency.conditions <- c(dependency.conditions, dependencies[[dependency.index]]$condition)
      dependency.result <- variable.summary$variables[[name]]$dependency.results[[dependency.index]]
      if (length(dependency.result) == 0) {
        dependency.result <- "all subjects pass"
      } else if (length(dependency.result) > 1) {
        dependency.result <- paste(sort(dependency.result), collapse = ", ")
      }
      dependency.results <- c(dependency.results, dependency.result)


      ## allow table_comparisons for simple contingency tables between this and other variables
      if (!is.null(dependencies[[dependency.index]]$table_comparisons)) {
        for (table.target in dependencies[[dependency.index]]$table_comparisons) {
          stopifnot(table.target %in% colnames(phenotype.data))
          comp.var.pretty.name <- variable.summary$variables[[table.target]]$original.name
          if (!is.null(variable.summary$variables[[table.target]]$params$canonical_name)) {
            comp.var.pretty.name <- paste(comp.var.pretty.name,
              " (",
              variable.summary$variables[[table.target]]$params$canonical_name,
              ")",
              sep = ""
            )
          }
          table.data <- table(
            phenotype.data[, table.target],
            phenotype.data[, name],
            useNA = "ifany"
          )
          result.tables$contingency <- knitr::kable(table.data,
            caption = paste("Contingency table for ",
              table.target,
              " (",
              comp.var.pretty.name,
              ") [rows] versus ",
              name,
              " [columns]",
              sep = ""
            )
          ) %>% kableExtra::kable_styling("condensed")
        }
      }
    }
    dependency.df <- data.frame(
      Name = dependency.names,
      Condition = dependency.conditions,
      Count = sapply(strsplit(dependency.results, ","), function(i) {
        ifelse(identical(i, "all subjects pass"), 0, length(i))
      }),
      Result = dependency.results
    )
    rownames(dependency.df) <- NULL
    result.tables$cross <- knitr::kable(dependency.df,
      caption = "Results of cross-variable dependency tests."
    ) %>% kableExtra::kable_styling("condensed")
  }
  result.tables
}

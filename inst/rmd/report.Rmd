---
title: "Report Template for Audited Phenotype Files"
output:
  html_document:
    code_folding: hide
    md_extensions: "-fancy_lists -emoji"
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
params:
  dataset.name: ""
  variable.summary: NULL
  phenotype.data: ""
  unique.variable.value.inclusion.proportion: 0.333
  subjects.wrong.type: c()
  variables.wrong.type: c()
  nas.by.subject: c()
  subjects.failing.deps: c()
  subj.invalid.type.max: 100
---

#### Link input parameters to local variables

```{r link.variables, eval=TRUE, echo=FALSE}
dataset.name <- params$dataset.name
variable.summary <- params$variable.summary
phenotype.data <- params$phenotype.data
unique.variable.value.inclusion.proportion <- params$unique.variable.value.inclusion.proportion
subjects.wrong.type <- params$subjects.wrong.type
variables.wrong.type <- params$variables.wrong.type
nas.by.subject <- params$nas.by.subject
subjects.failing.deps <- params$subjects.failing.deps
subj.invalid.type.max <- params$subj.invalid.type.max
```

#### Load required R packages

```{r load.packages, eval=TRUE, echo=FALSE}
library(ggplot2, quietly = TRUE)
library(RColorBrewer, quietly = TRUE)
library(knitr, quietly = TRUE)
library(kableExtra, quietly = TRUE)
```

***
<br>

#### Configure default themes for plotting/tables

```{r configure.ggplot2.theme, eval=TRUE, echo=FALSE}
my.theme <- theme_light() + theme(
  plot.title = element_text(size = 16, hjust = 0.5),
  axis.title = element_text(size = 14),
  axis.text = element_text(size = 12),
  strip.background = element_blank(),
  strip.text = element_text(size = 14, colour = "black"),
  legend.title = element_text(size = 14),
  legend.text = element_text(size = 13)
)

knitr.table.attr <- "style=\"width: 90%\""
knitr.contingency.table.attr <- "style=\"width: 50%\""
```

This report and the accompanying cleaned data is generated by the code available 
at <a href="https://gitlab.com/data-analysis5/process.phenotypes">this</a> repository, 
run using the configuration outlined in `r dataset.yaml`.
<br><br>
The report is a summary of the phenotype data and includes subject-level summary metrics, 
variable-level summary metrics, a linker between original variable names and standardized encoded names,
and per-variable summaries.  The per-variable summaries vary based on data type.  Numeric types will
display a histogram and min/max/mean/median/deciles.  Categorical and ordinal types display counts of each 
factor level.  All types other than string include a summary of data entries that are not consistent with 
the indicated data type.  Dependencies, bounds, data types, etc. are defined in the accompanying configuration
file.  
<br>
`r variable.summary$subjects.excluded.for.age` subjects were
removed for being below the minimum permissible age of
`r variable.summary$globals$min_age_for_inclusion`.
`r n.invalid.types.removed <- length(which(subjects.wrong.type >= subj.invalid.type.max))`
`r n.invalid.types.removed` `r if (n.invalid.types.removed == 1) {" subject "} else {" subjects "}`
will be removed from cleaned output data for containing more than `r subj.invalid.type.max` 
datapoints not matching the corresponding variable type.

***
<br>

### Subject level metrics

```{r report.subject.specific.na, eval=TRUE, echo=FALSE, results="asis"}
## probably want a histogram of this one
plot.data <- data.frame(x = nas.by.subject)
my.hist <- ggplot(aes(x = x, y = ..count.. / sum(..count..)), data = plot.data)
my.hist <- my.hist + my.theme + geom_histogram(bins = 50)
my.hist <- my.hist + xlab("Number of NA Values by Subject") + ylab("Proportion of Subjects")
cat("\n\n#### Distribution of NA Counts by Subject\n\n")
print(my.hist)
```

```{r report.subject.type.failures, eval=TRUE, echo=FALSE, results="asis"}
## probably also want a histogram of this one
plot.data <- data.frame(x = subjects.wrong.type)
my.hist <- ggplot(aes(x = x, y = ..count.. / nrow(phenotype.data)), data = plot.data)
my.hist <- my.hist + my.theme + geom_histogram(bins = 50)
my.hist <- my.hist + xlab("Number of Invalid Type Datapoints by Subject") + ylab("Proportion of Subjects")
my.hist <- my.hist + geom_vline(xintercept = subj.invalid.type.max, col = "red", lty = 2)
cat("\n\n#### Distribution of Invalid Type Datapoints by Subject\n\n")
print(my.hist)

knitr::kable(process.phenotypes:::get.top.ten(TRUE, subjects.wrong.type, "Subjects"), caption = "Ten highest type conversion failures", table.attr = knitr.table.attr)
```

***
<br>

```{r report.subject.dependency.failures, eval=TRUE, echo=FALSE, results="asis"}
## histogram time
plot.data <- data.frame(x = subjects.failing.deps)
my.hist <- ggplot(aes(x = x, y = ..count.. / nrow(phenotype.data)), data = plot.data)
my.hist <- my.hist + my.theme + geom_histogram(bins = 50)
my.hist <- my.hist + xlab("Number of Variable Dependency Failures by Subject") + ylab("Proportion of Subjects")
cat("\n\n#### Distribution of Dependency Failures by Subject\n\n")
print(my.hist)
```

***
<br>

### Variable level metrics

```{r report.variable.type.failures, eval=TRUE, echo=FALSE, results="asis"}
## for now, histogram this too
plot.data <- data.frame(x = variables.wrong.type)
my.hist <- ggplot(aes(x = x, y = ..count.. / sum(..count..)), data = plot.data)
my.hist <- my.hist + my.theme + geom_histogram(bins = 50)
my.hist <- my.hist + xlab("Number of Invalid Type Datapoints by Variable") + ylab("Proportion of Variables")
cat("\n\n#### Distribution of Invalid Type Datapoints by Variable\n\n")
print(my.hist)

knitr::kable(process.phenotypes:::get.top.ten(TRUE, variables.wrong.type, "Variables"), caption = "Ten highest type conversion failures", table.attr = knitr.table.attr)
```

### Report linking between input and standardized variable names

```{r report.variable.mappings, eval=TRUE, echo=FALSE, results="asis"}
variable.mapping.df <- data.frame(
  names(variable.summary$variables),
  sapply(variable.summary$variables, function(i) {
    i$original.name
  })
)
rownames(variable.mapping.df) <- NULL
colnames(variable.mapping.df) <- c("Standardized", "Original")
knitr::kable(variable.mapping.df, caption = "Phenotype Variable Names", table.attr = knitr.table.attr)
```

***
<br>

### Report variable distribution summaries

In this section, each variable in turn is summarized according
to the variable's configured type.

***
<br>

```{r report.value.summary, eval=TRUE, echo=FALSE, results="asis"}
for (name in names(variable.summary$variables)) {
  my.summ <- variable.summary$variables[[name]]$summary
  variable.pretty.name <- variable.summary$variables[[name]]$original.name
  suppress.reporting <- FALSE
  if (!is.null(variable.summary$variables[[name]]$params$suppress_reporting)) {
    suppress.reporting <- variable.summary$variables[[name]]$params$suppress_reporting
  }
  cat(
    "\n\n### ", variable.pretty.name, "\n\n"
  )
  if (!is.null(variable.summary$variables[[name]]$params$canonical_name)) {
    cat(
      "Official variable identity: \"",
      variable.summary$variables[[name]]$params$canonical_name, "\"", "\n\n"
    )
  }
  if (!is.null(variable.summary$variables[[name]]$params$code)) {
    cat(
      "\n\nThe logic to create this derived variable is as follows:\n\n```\n",
      variable.summary$variables[[name]]$params$code, "\n```\n\n",
      sep = ""
    )
  }

  ## report any indication of residual Excel junk in the variable
  if (!is.null(variable.summary$variables[[name]]$excel.problem.count)) {
    if (variable.summary$variables[[name]]$excel.problem.count == 1) {
      cat("\nWARNING: 1 Excel error code detected in this variable.\n")
    } else {
      cat("\nWARNING: ", variable.summary$variables[[name]]$excel.problem.count,
        " Excel error codes detected in this variable.\n",
        sep = ""
      )
    }
  }
  ## if the source data type is numeric
  if (is.vector(phenotype.data[, name], mode = "numeric")) {
    if (length(which(!is.na(phenotype.data[, name])))) {
      ## create data histogram for numeric data
      nbins <- 50
      plot.data <- data.frame(x = phenotype.data[!is.na(phenotype.data[, name]), name])
      hist.plot <- ggplot(data = plot.data) + my.theme

      if (!is.null(variable.summary$variables[[name]]$params$multimodal)) {
        multimodal.varname <- variable.summary$variables[[name]]$params$multimodal
        stopifnot(multimodal.varname %in% colnames(phenotype.data))
        multimodal.values <- unique(phenotype.data[, multimodal.varname])
        hist.plot.colours <- RColorBrewer::brewer.pal(max(3, length(multimodal.values)), "Dark2")[seq_len(length(multimodal.values))]
        annotate.y <- max(hist(phenotype.data[, name], breaks = nbins, plot = FALSE)$counts) / nrow(phenotype.data)
        for (i in seq_len(length(multimodal.values))) {
          if (length(which(phenotype.data[, multimodal.varname] == multimodal.values[i] &
            !is.na(phenotype.data[, multimodal.varname]))) == 0) {
            next
          }
          plot.subset <- phenotype.data[phenotype.data[, multimodal.varname] == multimodal.values[i] &
            !is.na(phenotype.data[, name]) & !is.na(phenotype.data[, multimodal.varname]), ]
          hist.plot <- hist.plot + geom_histogram(aes_string(
            x = name,
            y = "..count../sum(..count..)"
          ),
          data = plot.subset,
          bins = nbins,
          fill = hist.plot.colours[i],
          alpha = 0.2
          )
          mode.mean <- mean(plot.subset[, name],
            na.rm = TRUE
          )
          hist.plot <- hist.plot + geom_vline(
            xintercept = mode.mean,
            colour = hist.plot.colours[i]
          )
          hist.plot <- hist.plot + annotate("text",
            label = multimodal.values[i],
            x = mode.mean * 1.15,
            y = annotate.y * (1 - (i - 1) * 0.05),
            size = 3,
            hjust = 0,
            colour = hist.plot.colours[i]
          )
        }
      } else {
        hist.plot <- hist.plot + geom_histogram(
          aes(x = x, y = ..count.. / sum(..count..)),
          bins = nbins
        )
      }
      hist.plot <- hist.plot + xlab(name) + ylab("proportion of data")
      if (is.null(variable.summary$variables[[name]]$params$bounds$sd)) {
        var.mean <- mean(phenotype.data[, name], na.rm = TRUE)
        var.sd <- sd(phenotype.data[, name], na.rm = TRUE)
        hist.plot <- hist.plot + geom_vline(xintercept = var.mean + 3 * var.sd, linetype = "dashed")
        hist.plot <- hist.plot + geom_vline(xintercept = var.mean - 3 * var.sd, linetype = "dashed")
      }
      cat(
        "\n\n#### Histogram of ", name, " (", variable.pretty.name,
        ") Distribution\n\n",
        sep = ""
      )
      print(hist.plot)
    }
    if (!is.null(variable.summary$variables[[name]]$params$bounds)) {
      bound.type <- c()
      bound.value <- c()
      bound.count <- c()
      if (!is.null(variable.summary$variables[[name]]$params$bounds$min)) {
        bound.type <- c(bound.type, "minimum")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$min)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.below.min)
      }
      if (!is.null(variable.summary$variables[[name]]$params$bounds$max)) {
        bound.type <- c(bound.type, "maximum")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$max)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.above.max)
      }
      if (!is.null(variable.summary$variables[[name]]$params$bounds$sd)) {
        bound.type <- c(bound.type, "standard deviation")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$sd)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.beyond.sd)
      }
      bound.df <- data.frame(
        Type = bound.type,
        Value = bound.value,
        Count = bound.count
      )
      rownames(bound.df) <- NULL
      table.caption <- paste("Numeric bounds on ", name, " (", variable.pretty.name, ")", sep = "")
      print(knitr::kable(bound.df, caption = table.caption, table.attr = knitr.table.attr))
    }
  }
  ## if the source data has a linked_date variable, indicating it is an age
  ## that in theory should be derived from a date
  if (!is.null(variable.summary$variables[[name]]$params$linked_date)) {
    reported.year.varname <- variable.summary$variables[[name]]$params$linked_date$reported_year
    reference.year <- variable.summary$variables[[name]]$params$linked_date$reference_year
    stopifnot(
      reported.year.varname %in% names(variable.summary$variables),
      is.numeric(reference.year) |
        (is.character(reference.year) & reference.year %in% names(variable.summary$variables))
    )
    reported.year <- phenotype.data[, reported.year.varname]
    if (is.character(reference.year)) {
      reference.year <- phenotype.data[, reference.year]
    }
    reported.age <- phenotype.data[, name]
    derived.age <- reference.year - reported.year
    plot.data <- data.frame(
      x = reported.age,
      y = derived.age
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    age.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    age.plot <- age.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    age.plot <- age.plot + xlab("Reported Age") + ylab("Age Computed from Date")
    cat("\n\n#### Comparison between reported age ", name, " and age derived from date ",
      reported.year.varname, "\n\n",
      sep = ""
    )
    print(age.plot)
  }
  ## if the source data has a computed_bmi variable, indicating it is BMI
  ## that in theory should be derived from height and weight
  if (!is.null(variable.summary$variables[[name]]$params$computed_bmi)) {
    height.varname <- variable.summary$variables[[name]]$params$computed_bmi$height
    weight.varname <- variable.summary$variables[[name]]$params$computed_bmi$weight
    stopifnot(
      height.varname %in% colnames(phenotype.data),
      weight.varname %in% colnames(phenotype.data)
    )
    reported.bmi <- phenotype.data[, name]
    height.var <- phenotype.data[, height.varname]
    weight.var <- phenotype.data[, weight.varname]
    computed.bmi <- weight.var / height.var^2
    plot.data <- data.frame(
      x = reported.bmi,
      y = computed.bmi
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    bmi.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    bmi.plot <- bmi.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    bmi.plot <- bmi.plot + xlab("Reported BMI") + ylab("BMI Computed from Height/Weight")
    cat("\n\n#### Comparison between reported BMI ", name,
      " and BMI derived from height ", height.varname,
      " and weight ", weight.varname, "\n\n",
      sep = ""
    )
    print(bmi.plot)
  }
  ## if the source data has a computed_bp_ratio variable, plot the ratio
  ## between the systolic and diastolic measurements as indicated
  if (!is.null(variable.summary$variables[[name]]$params$computed_bp_ratio)) {
    systolic.bp <- phenotype.data[, name]
    diastolic.bp.varname <- variable.summary$variables[[name]]$params$computed_bp_ratio$diastolic
    stopifnot(diastolic.bp.varname %in% colnames(phenotype.data))
    diastolic.bp <- phenotype.data[, diastolic.bp.varname]
    plot.data <- data.frame(x = systolic.bp, y = diastolic.bp)
    bp.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    bp.plot <- bp.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    bp.plot <- bp.plot + xlab("Reported systolic BP") + ylab("Reported diastolic BP")
    cat("\n\n#### Comparison between reported systolic ", name,
      " and diastolic blood pressure ", diastolic.bp.varname, "\n\n",
      sep = ""
    )
    print(bp.plot)
  }
  ## original exclusion criterion here is hitting everything for small datasets,
  ## even when the report is not a unique value report
  if (is.vector(phenotype.data[, name], mode = "numeric") |
    ((is.factor(phenotype.data[, name]) |
      length(my.summ) < nrow(phenotype.data) * unique.variable.value.inclusion.proportion) & !suppress.reporting)) {
    variable.summary.df <- data.frame(
      names(my.summ), as.vector(my.summ)
    )
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([0-9]+)\\. ", "\\1\\2\\\\. ")
    rownames(variable.summary.df) <- NULL
    colnames(variable.summary.df) <- c("Value", "Summary statistics")
    table.caption <- paste("Summary of ", name, " (", variable.pretty.name, ")", sep = "")
    print(knitr::kable(variable.summary.df, caption = table.caption, table.attr = knitr.table.attr))
  } else if (length(my.summ) >= nrow(phenotype.data) * unique.variable.value.inclusion.proportion) {
    cat("\n\nVariable ", name, " (", variable.pretty.name, ") has ", length(my.summ), " unique values, and thus",
      " report output of individual value counts is suppressed.\n\n",
      sep = ""
    )
  } else if (suppress.reporting) {
    cat("\n\nReporting for this variable was suppressed in the configuration.\n\n")
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.blood.pressure.entries)) {
    if (length(variable.summary$variables[[name]]$invalid.blood.pressure.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.blood.pressure.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      print(knitr::kable(df, caption = "Values that were not consistent with blood pressure measurement format.", table.attr = knitr.table.attr))
    } else {
      cat("\n\nAll values consistent with blood pressure format or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.numeric.entries)) {
    if (length(variable.summary$variables[[name]]$invalid.numeric.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.numeric.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      print(knitr::kable(df, caption = "Values that were not consistent with numeric format.", table.attr = knitr.table.attr))
    } else {
      cat("\n\nAll values consistent with numeric format or missing data.\n\n")
    }
  }
  ## factors
  ## give ancestry factor variable special treatment
  if (!is.null(variable.summary$variables[[name]]$params$subject_ancestry)) {
    ## instead of reporting failed conversions specifically,
    ## report a table of all imperfect matches to the reference ancestry labels,
    ## and track the outcomes for all of them, even the ones that were eventually
    ## called. this behavior may be updated later once this method has been
    ## improved
    df <- data.frame(
      variable.summary$variables[[name]]$ancestry.conversion.before,
      variable.summary$variables[[name]]$ancestry.conversion.after,
      variable.summary$variables[[name]]$ancestry.reasoning,
      variable.summary$variables[[name]]$ancestry.best.match,
      round(variable.summary$variables[[name]]$ancestry.best.value, 2),
      variable.summary$variables[[name]]$ancestry.second.match,
      round(variable.summary$variables[[name]]$ancestry.second.value, 2)
    )
    colnames(df) <- c(
      "Input",
      "Output",
      "Reasoning",
      "Best Match",
      "Best Score",
      "Second Match",
      "Second Score"
    )
    df$Count <- rep(0, nrow(df))
    for (query in unique(df[, 1])) {
      df$Count[df[, 1] == query] <- length(which(df[, 1] == query))
    }

    ## clean up table: for large datasets, this gets unwieldy
    ## first remove duplicate queries, as the resolution is always the same
    df <- df[!duplicated(df[, 1]), ]
    ## then sort first by reasoning, then by output, then by query
    df <- df[order(df[, 3], df[, 2], df[, 1]), ]
    rownames(df) <- NULL
    print(knitr::kable(df, caption = "Handling of all partial match self-reported ancestries.", table.attr = knitr.table.attr))
  } else if (!is.null(variable.summary$variables[[name]]$invalid.factor.entries)) {
    ## other things that are factors
    if (length(variable.summary$variables[[name]]$invalid.factor.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.factor.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      print(knitr::kable(df, caption = "Values that were not consistent with categorical format.", table.attr = knitr.table.attr))
    } else {
      cat("\n\nAll values consistent with categorical format or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.date.entries)) {
    if (length(variable.summary$variables[[name]]$invalid.date.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.date.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      print(knitr::kable(df, caption = "Values that were not consistent with date (year only) format.", table.attr = knitr.table.attr))
    } else {
      cat("\n\nAll values consistent with date format (year only) or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$unicode.entries)) {
    unicode.df <- data.frame(
      names(variable.summary$variables[[name]]$unicode.entries),
      as.vector(variable.summary$variables[[name]]$unicode.entries)
    )
    rownames(unicode.df) <- NULL
    colnames(unicode.df) <- c("Unicode String", "Observations")
    print(knitr::kable(unicode.df, caption = "String entries containing unresolved Unicode characters.", table.attr = knitr.table.attr))
  }
  if (!is.null(variable.summary$variables[[name]]$params$dependencies)) {
    cat("\n\n#### Dependency tracking\n\n")
    dependency.names <- c()
    dependency.conditions <- c()
    dependency.results <- c()
    dependencies <- variable.summary$variables[[name]]$params$dependencies
    for (dependency.index in names(dependencies)) {
      dependency.names <- c(dependency.names, dependencies[[dependency.index]]$name)
      dependency.conditions <- c(dependency.conditions, dependencies[[dependency.index]]$condition)
      dependency.result <- variable.summary$variables[[name]]$dependency.results[[dependency.index]]
      if (length(dependency.result) == 0) {
        dependency.result <- "all subjects pass"
      } else if (length(dependency.result) > 1) {
        dependency.result <- paste(dependency.result, collapse = ", ")
      }
      dependency.results <- c(dependency.results, dependency.result)


      ## allow table_comparisons for simple contingency tables between this and other variables
      if (!is.null(dependencies[[dependency.index]]$table_comparisons)) {
        for (table.target in dependencies[[dependency.index]]$table_comparisons) {
          stopifnot(table.target %in% colnames(phenotype.data))
          comparison.variable.pretty.name <- variable.summary$variables[[table.target]]$original.name
          if (!is.null(variable.summary$variables[[table.target]]$params$canonical_name)) {
            comparison.variable.pretty.name <- paste(comparison.variable.pretty.name,
              " (",
              variable.summary$variables[[table.target]]$params$canonical_name,
              ")",
              sep = ""
            )
          }
          table.data <- table(
            phenotype.data[, table.target],
            phenotype.data[, name],
            useNA = "ifany"
          )
          print(knitr::kable(table.data,
            caption = paste("Contingency table for ",
              table.target,
              " (",
              comparison.variable.pretty.name,
              ") [rows] versus ",
              name,
              " [columns]",
              sep = ""
            ),
            table.attr = knitr.contingency.table.attr
          ))
        }
      }
    }
    dependency.df <- data.frame(
      Name = dependency.names,
      Condition = dependency.conditions,
      Count = sapply(strsplit(dependency.results, ","), function(i) {
        length(i)
      }),
      Result = dependency.results
    )
    rownames(dependency.df) <- NULL
    print(knitr::kable(dependency.df,
      caption = "Results of cross-variable dependency tests.",
      table.attr = knitr.table.attr
    ))
  }

  cat("\n***\n<br>\n")
}
```

***
<br>

#### Session Information

<br>

The following summarizes the loaded R configuration for the run that created this report.

```{r session.info, eval=TRUE, echo=TRUE}
sessionInfo()
```

---
title: "Phenotype Quality Control Report"
output:
  html_document:
    code_folding: hide
    md_extensions: "-fancy_lists -emoji"
  highlight: tango
  number_sections: no
  theme: default
  toc: yes
  toc_depth: 3
  toc_float:
    collapsed: no
    smooth_scroll: yes
params:
  dataset.name: ""
  variable.summary: NULL
  phenotype.data: ""
  unique.variable.value.inclusion.proportion: 0.333
  subjects.wrong.type: c()
  variables.wrong.type: c()
  nas.by.subject: c()
  subjects.failing.deps: c()
  subj.invalid.type.max: 100
---

```{r link.variables, eval=TRUE, echo=FALSE}
#### Link input parameters to local variables
dataset.name <- params$dataset.name
variable.summary <- params$variable.summary
phenotype.data <- params$phenotype.data
unique.variable.value.inclusion.proportion <- params$unique.variable.value.inclusion.proportion
subjects.wrong.type <- params$subjects.wrong.type
variables.wrong.type <- params$variables.wrong.type
nas.by.subject <- params$nas.by.subject
subjects.failing.deps <- params$subjects.failing.deps
subj.invalid.type.max <- params$subj.invalid.type.max
```

```{r load.packages, eval=TRUE, echo=FALSE}
#### Load required R packages
suppressPackageStartupMessages(library(ggplot2, quietly = TRUE))
suppressPackageStartupMessages(library(RColorBrewer, quietly = TRUE))
suppressPackageStartupMessages(library(knitr, quietly = TRUE))
suppressPackageStartupMessages(library(kableExtra, quietly = TRUE))
```

```{r get.bins, eval=TRUE, echo=FALSE}
#### Make sure the number of bins in a histogram isn't too close to the number of unique values!
get.bins <- function(vec) {
  n.unique.values <- length(unique(vec))
  if (n.unique.values > 50) {
    50
  } else {
    n.unique.values
  }
}
```

***
<br>

```{r configure.ggplot2.theme, eval=TRUE, echo=FALSE}
#### Configure default themes for plotting/tables
my.theme <- theme_light() + theme(
  plot.title = element_text(size = 16, hjust = 0.5),
  axis.title = element_text(size = 14),
  axis.text = element_text(size = 12),
  strip.background = element_blank(),
  strip.text = element_text(size = 14, colour = "black"),
  legend.title = element_text(size = 14),
  legend.text = element_text(size = 13)
)
```

This report and the accompanying cleaned data is generated by the code available 
at <a href="https://gitlab.com/data-analysis5/process.phenotypes">this</a> repository, 
run using the configuration outlined in `r dataset.yaml`.
<br><br>
The report is a summary of the phenotype data and includes subject-level summary metrics, 
variable-level summary metrics, a linker between original variable names and standardized encoded names,
and per-variable summaries.  The per-variable summaries vary based on data type.  Numeric types will
display a histogram and min/max/mean/median/deciles.  Categorical and ordinal types display counts of each 
factor level.  All types other than string include a summary of data entries that are not consistent with 
the indicated data type.  Dependencies, bounds, data types, etc. are defined in the accompanying configuration
file.  
<br>
`r paste(variable.summary$total.initial.sample.size, ifelse(variable.summary$total.initial.sample.size == 1, " subject was", " subjects were"), " originally present in this dataset.", ifelse(!is.null(variable.summary$globals$consent_inclusion_file), paste(" ", variable.summary$subjects.consent.yes, ifelse(variable.summary$subjects.consent.yes == 1, " subject was", " subjects were"), " included with verified consent.", sep = ""), ""), ifelse(!is.null(variable.summary$globals$consent_exclusion_file), paste(" ", variable.summary$subjects.consent.no, ifelse(variable.summary$subjects.consent.no == 1, " subject was", " subjects were"), " excluded for lacking consent.", sep = ""), ""), ifelse(!is.null(variable.summary$globals$consent_inclusion_file) & !is.null(variable.summary$globals$consent_exclusion_file), paste(" ", length(variable.summary$subjects.ambiguous.consent), ifelse(length(variable.summary$subjects.ambiguous.consent) == 1, " subject was", " subjects were"), " additionally excluded for not being explicitly listed as either having or lacking consent.", sep = ""), ""), " ", variable.summary$subjects.excluded.for.age, ifelse(variable.summary$subjects.excluded.for.age == 1, " subject was ", " subjects were "), "removed for being below the minimum permissible age of ", variable.summary$globals$min_age_for_inclusion, ".", sep = "")`

`r if (length(variable.summary$subjects.ambiguous.consent) > 0) {paste("***\n<br>")}`

```{r report.consent.ambiguity, eval=length(variable.summary$subjects.ambiguous.consent) > 0, echo=FALSE, results="asis"}
ambig.consent <- data.frame(x = sort(variable.summary$subjects.ambiguous.consent))
colnames(ambig.consent) <- c("Subject ID")
knitr::kable(ambig.consent, caption = "Subjects Absent from Consent Tracking") %>%
  kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
```

***
<br>

```{r report.invalid.type.removal, eval=TRUE, echo=FALSE, results="asis"}
n.invalid.types.removed <- 0
if (!is.null(subj.invalid.type.max)) {
  n.invalid.types.removed <- length(which(subjects.wrong.type >= subj.invalid.type.max))
  cat("\n",
    n.invalid.types.removed,
    ifelse(n.invalid.types.removed == 1, "subject", "subjects"),
    "will be removed from cleaned output data for containing more than",
    subj.invalid.type.max,
    "datapoints not matching the corresponding variable type.\n",
    sep = " "
  )
}
```
<br>
`r as.integer(nrow(phenotype.data) - n.invalid.types.removed)` subjects remain in the cleaned dataset.
Based on configured dependency relationships between variables,
`r variable.summary$actual.nas.from.deps` of `r variable.summary$possible.nas.from.deps`,
or `r ifelse(variable.summary$possible.nas.from.deps == 0, 0, round(variable.summary$actual.nas.from.deps / variable.summary$possible.nas.from.deps, 2))`%,
of possible datapoint exclusions `r ifelse(variable.summary$actual.nas.from.deps == 1, "was", "were")` set to NA
due to failed dependencies.

***
<br>

### Subject level metrics

```{r report.subject.specific.na, eval=TRUE, echo=FALSE, results="asis"}
## probably want a histogram of this one
plot.data <- data.frame(x = nas.by.subject)
my.hist <- ggplot(aes(x = x, y = ..count.. / sum(..count..)), data = plot.data)
nbins <- get.bins(nas.by.subject)
my.hist <- my.hist + my.theme + geom_histogram(bins = nbins, binwidth = (diff(range(nas.by.subject)) + 1) / nbins)
my.hist <- my.hist + xlab("Number of NA Values by Subject") + ylab("Proportion of Subjects")
cat("\n\n#### Distribution of NA Counts by Subject\n\n")
print(my.hist)

knitr::kable(process.phenotypes:::get.top.ten(TRUE, nas.by.subject, "Subjects"), caption = "Ten highest NA-count subjects") %>%
  kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
```

```{r report.subject.type.failures, eval=length(subjects.wrong.type) > 0, echo=FALSE, results="asis"}
## probably also want a histogram of this one
plot.data <- data.frame(x = subjects.wrong.type)
my.hist <- ggplot(aes(x = x, y = ..count.. / nrow(phenotype.data)), data = plot.data)
nbins <- get.bins(subjects.wrong.type)
my.hist <- my.hist + my.theme + geom_histogram(bins = nbins, binwidth = (diff(range(subjects.wrong.type)) + 1) / nbins)
my.hist <- my.hist + xlab("Number of Invalid Type Datapoints by Subject") + ylab("Proportion of Subjects")
my.hist <- my.hist + geom_vline(xintercept = subj.invalid.type.max, col = "red", lty = 2)
cat("\n\n#### Distribution of Invalid Type Datapoints by Subject\n\n")
print(my.hist)

knitr::kable(process.phenotypes:::get.top.ten(TRUE, subjects.wrong.type, "Subjects"), caption = "Ten highest type conversion failures") %>%
  kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
```

***
<br>

```{r report.subject.dependency.failures, eval=length(which(subjects.failing.deps > 0)) > 0, echo=FALSE, results="asis"}
## histogram time
plot.data <- data.frame(x = subjects.failing.deps)
my.hist <- ggplot(aes(x = x, y = ..count.. / nrow(phenotype.data)), data = plot.data)
nbins <- get.bins(subjects.failing.deps)
my.hist <- my.hist + my.theme + geom_histogram(bins = nbins, binwidth = (diff(range(subjects.failing.deps)) + 1) / nbins)
my.hist <- my.hist + xlab("Number of Variable Dependency Failures by Subject") + ylab("Proportion of Subjects")
cat("\n\n#### Distribution of Dependency Failures by Subject\n\n")
print(my.hist)
```

***
<br>

`r if (length(which(variables.wrong.type > 0)) > 0) {"### Variable level metrics"}`

```{r report.variable.type.failures, eval=length(which(variables.wrong.type > 0)) > 0, echo=FALSE, results="asis"}
## for now, histogram this too
plot.data <- data.frame(x = variables.wrong.type)
my.hist <- ggplot(aes(x = x, y = ..count.. / sum(..count..)), data = plot.data)
nbins <- get.bins(variables.wrong.type)
my.hist <- my.hist + my.theme + geom_histogram(bins = nbins, binwidth = (diff(range(variables.wrong.type)) + 1) / nbins)
my.hist <- my.hist + xlab("Number of Invalid Type Datapoints by Variable") + ylab("Proportion of Variables")
cat("\n\n#### Distribution of Invalid Type Datapoints by Variable\n\n")
print(my.hist)

knitr::kable(process.phenotypes:::get.top.ten(TRUE, variables.wrong.type, "Variables"), caption = "Ten highest type conversion failures") %>%
  kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
```

### Report linking between input and standardized variable names

```{r report.variable.mappings, eval=TRUE, echo=FALSE, results="asis"}
variable.mapping.df <- data.frame(
  names(variable.summary$variables),
  sapply(variable.summary$variables, function(i) {
    i$original.name
  }),
  sapply(variable.summary$variables, function(i) {
    if (!is.null(i$params$canonical_name)) {
      i$params$canonical_name
    } else {
      ""
    }
  })
)
rownames(variable.mapping.df) <- NULL
colnames(variable.mapping.df) <- c("Standardized", "Original", "Description")
knitr::kable(variable.mapping.df, caption = "Phenotype Variable Names") %>%
  kableExtra::kable_styling("condensed", position = "left", full_width = FALSE)
```

***
<br>

### Report variable distribution summaries

In this section, each variable in turn is summarized according
to the variable's configured type.

***
<br>

```{r report.value.summary, eval=TRUE, echo=FALSE, results="asis"}
for (name in names(variable.summary$variables)) {
  my.summ <- variable.summary$variables[[name]]$summary
  variable.pretty.name <- variable.summary$variables[[name]]$original.name
  suppress.reporting <- FALSE
  if (!is.null(variable.summary$variables[[name]]$params$suppress_reporting)) {
    suppress.reporting <- variable.summary$variables[[name]]$params$suppress_reporting
  }
  cat(
    "\n\n### ", variable.pretty.name, "\n\n"
  )
  if (!is.null(variable.summary$variables[[name]]$params$canonical_name)) {
    cat(
      "Official variable identity: \"",
      variable.summary$variables[[name]]$params$canonical_name, "\"", "\n\n"
    )
  }
  if (!is.null(variable.summary$variables[[name]]$params$code)) {
    cat(
      "\n\nThe logic to create this derived variable is as follows:\n\n```\n",
      variable.summary$variables[[name]]$params$code, "\n```\n\n",
      sep = ""
    )
  }

  ## report any indication of residual Excel junk in the variable
  if (!is.null(variable.summary$variables[[name]]$excel.problem.count) & !suppress.reporting) {
    if (variable.summary$variables[[name]]$excel.problem.count == 1) {
      cat("\nWARNING: 1 Excel error code detected in this variable.\n")
    } else {
      cat("\nWARNING: ", variable.summary$variables[[name]]$excel.problem.count,
        " Excel error codes detected in this variable.\n",
        sep = ""
      )
    }
  }
  ## if the source data type is numeric
  if (is.vector(phenotype.data[, name], mode = "numeric") & !suppress.reporting) {
    if (length(which(!is.na(phenotype.data[, name])))) {
      ## create data histogram for numeric data
      plot.data <- data.frame(x = phenotype.data[!is.na(phenotype.data[, name]), name])
      if (length(unique(plot.data$x)) > 0) {
        hist.plot <- ggplot(data = plot.data) + my.theme
        nbins <- get.bins(phenotype.data[!is.na(phenotype.data[, name]), name])
        binwidth <- (diff(range(phenotype.data[!is.na(phenotype.data[, name]), name])) + 1) / nbins
        if (!is.null(variable.summary$variables[[name]]$params$multimodal)) {
          multimodal.varname <- variable.summary$variables[[name]]$params$multimodal
          stopifnot(multimodal.varname %in% colnames(phenotype.data))
          multimodal.values <- unique(phenotype.data[, multimodal.varname])
          hist.plot.colours <- RColorBrewer::brewer.pal(max(3, length(multimodal.values)), "Dark2")[seq_len(length(multimodal.values))]
          annotate.y <- max(hist(phenotype.data[, name], breaks = nbins, plot = FALSE)$counts) / nrow(phenotype.data)
          for (i in seq_len(length(multimodal.values))) {
            if (length(which(phenotype.data[, multimodal.varname] == multimodal.values[i] &
              !is.na(phenotype.data[, multimodal.varname]))) == 0) {
              next
            }
            plot.subset <- phenotype.data[phenotype.data[, multimodal.varname] == multimodal.values[i] &
              !is.na(phenotype.data[, name]) & !is.na(phenotype.data[, multimodal.varname]), ]
            hist.plot <- hist.plot + geom_histogram(aes_string(
              x = name,
              y = "..count../sum(..count..)"
            ),
            data = plot.subset,
            bins = nbins,
            binwidth = binwidth,
            fill = hist.plot.colours[i],
            alpha = 0.2
            )
            mode.mean <- mean(plot.subset[, name],
              na.rm = TRUE
            )
            hist.plot <- hist.plot + geom_vline(
              xintercept = mode.mean,
              colour = hist.plot.colours[i]
            )
            hist.plot <- hist.plot + annotate("text",
              label = multimodal.values[i],
              x = mode.mean * 1.15,
              y = annotate.y * (1 - (i - 1) * 0.05),
              size = 3,
              hjust = 0,
              colour = hist.plot.colours[i]
            )
          }
        } else {
          hist.plot <- hist.plot + geom_histogram(
            aes(x = x, y = ..count.. / sum(..count..)),
            bins = nbins,
            binwidth = binwidth
          )
        }
        hist.plot <- hist.plot + xlab(name) + ylab("proportion of data")
        if (is.null(variable.summary$variables[[name]]$params$bounds$sd)) {
          var.mean <- mean(phenotype.data[, name], na.rm = TRUE)
          var.sd <- sd(phenotype.data[, name], na.rm = TRUE)
          hist.plot <- hist.plot + geom_vline(xintercept = var.mean + 3 * var.sd, linetype = "dashed")
          hist.plot <- hist.plot + geom_vline(xintercept = var.mean - 3 * var.sd, linetype = "dashed")
        }
        cat(
          "\n\n#### Histogram of ", name, " (", variable.pretty.name,
          ") Distribution\n\n",
          sep = ""
        )
        print(hist.plot)
      }
    }
    if (!is.null(variable.summary$variables[[name]]$params$bounds)) {
      bound.type <- c()
      bound.value <- c()
      bound.count <- c()
      if (!is.null(variable.summary$variables[[name]]$params$bounds$min)) {
        bound.type <- c(bound.type, "minimum")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$min)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.below.min)
      }
      if (!is.null(variable.summary$variables[[name]]$params$bounds$max)) {
        bound.type <- c(bound.type, "maximum")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$max)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.above.max)
      }
      if (!is.null(variable.summary$variables[[name]]$params$bounds$sd)) {
        bound.type <- c(bound.type, "standard deviation")
        bound.value <- c(bound.value, variable.summary$variables[[name]]$params$bounds$sd)
        bound.count <- c(bound.count, variable.summary$variables[[name]]$num.beyond.sd)
      }
      bound.df <- data.frame(
        Type = bound.type,
        Value = bound.value,
        Count = bound.count
      )
      rownames(bound.df) <- NULL
      table.caption <- paste("Numeric bounds on ", name, " (", variable.pretty.name, ")", sep = "")
      cat(knitr::kable(bound.df, caption = table.caption) %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
    }
  }
  ## if the source data has a linked_date variable, indicating it is an age
  ## that in theory should be derived from a date
  if (!is.null(variable.summary$variables[[name]]$params$linked_date) & !suppress.reporting) {
    reported.year.varname <- variable.summary$variables[[name]]$params$linked_date$reported_year
    reference.year <- variable.summary$variables[[name]]$params$linked_date$reference_year
    stopifnot(
      reported.year.varname %in% names(variable.summary$variables),
      is.numeric(reference.year) |
        (is.character(reference.year) & reference.year %in% names(variable.summary$variables))
    )
    reported.year <- phenotype.data[, reported.year.varname]
    if (is.character(reference.year)) {
      reference.year <- phenotype.data[, reference.year]
    }
    reported.age <- phenotype.data[, name]
    derived.age <- reference.year - reported.year
    plot.data <- data.frame(
      x = reported.age,
      y = derived.age
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    age.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    age.plot <- age.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    age.plot <- age.plot + xlab("Reported Age") + ylab("Age Computed from Date")
    cat("\n\n#### Comparison between reported age ", name, " and age derived from date ",
      reported.year.varname, "\n\n",
      sep = ""
    )
    print(age.plot)
  }
  ## if the source data has a computed_bmi variable, indicating it is BMI
  ## that in theory should be derived from height and weight
  if (!is.null(variable.summary$variables[[name]]$params$computed_bmi) & !suppress.reporting) {
    height.varname <- variable.summary$variables[[name]]$params$computed_bmi$height
    weight.varname <- variable.summary$variables[[name]]$params$computed_bmi$weight
    stopifnot(
      height.varname %in% colnames(phenotype.data),
      weight.varname %in% colnames(phenotype.data)
    )
    reported.bmi <- phenotype.data[, name]
    height.var <- phenotype.data[, height.varname]
    weight.var <- phenotype.data[, weight.varname]
    computed.bmi <- weight.var / height.var^2
    plot.data <- data.frame(
      x = reported.bmi,
      y = computed.bmi
    )
    plot.data <- plot.data[!is.na(plot.data$x) & !is.na(plot.data$y), ]
    bmi.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    bmi.plot <- bmi.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    bmi.plot <- bmi.plot + xlab("Reported BMI") + ylab("BMI Computed from Height/Weight")
    cat("\n\n#### Comparison between reported BMI ", name,
      " and BMI derived from height ", height.varname,
      " and weight ", weight.varname, "\n\n",
      sep = ""
    )
    print(bmi.plot)
  }
  ## if the source data has a computed_bp_ratio variable, plot the ratio
  ## between the systolic and diastolic measurements as indicated
  if (!is.null(variable.summary$variables[[name]]$params$computed_bp_ratio) & !suppress.reporting) {
    systolic.bp <- phenotype.data[, name]
    diastolic.bp.varname <- variable.summary$variables[[name]]$params$computed_bp_ratio$diastolic
    stopifnot(diastolic.bp.varname %in% colnames(phenotype.data))
    diastolic.bp <- phenotype.data[, diastolic.bp.varname]
    plot.data <- data.frame(x = systolic.bp, y = diastolic.bp)
    bp.plot <- ggplot(aes(x = x, y = y), data = plot.data) + my.theme
    bp.plot <- bp.plot + geom_point() + geom_abline(slope = 1, intercept = 0)
    bp.plot <- bp.plot + xlab("Reported systolic BP") + ylab("Reported diastolic BP")
    cat("\n\n#### Comparison between reported systolic ", name,
      " and diastolic blood pressure ", diastolic.bp.varname, "\n\n",
      sep = ""
    )
    print(bp.plot)
  }
  ## original exclusion criterion here is hitting everything for small datasets,
  ## even when the report is not a unique value report
  if ((is.vector(phenotype.data[, name], mode = "numeric") & !suppress.reporting) |
    ((is.factor(phenotype.data[, name]) |
      length(my.summ) < nrow(phenotype.data) * unique.variable.value.inclusion.proportion) & !suppress.reporting)) {
    variable.summary.df <- data.frame(
      names(my.summ), as.vector(my.summ)
    )
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
    variable.summary.df[, 1] <- stringr::str_replace(variable.summary.df[, 1], "^( *)([0-9]+)\\. ", "\\1\\2\\\\. ")
    rownames(variable.summary.df) <- NULL
    colnames(variable.summary.df) <- c("Value", "Summary statistics")
    table.caption <- paste("Summary of ", name, " (", variable.pretty.name, ")", sep = "")
    cat(knitr::kable(variable.summary.df, caption = table.caption) %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
  } else if (length(my.summ) >= nrow(phenotype.data) * unique.variable.value.inclusion.proportion & !suppress.reporting) {
    cat("\n\nVariable ", name, " (", variable.pretty.name, ") has ", length(my.summ), " unique values, and thus",
      " report output of individual value counts is suppressed.\n\n",
      sep = ""
    )
  } else if (suppress.reporting) {
    cat("\n\nReporting for this variable was suppressed in the configuration.\n\n")
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.blood.pressure.entries) & !suppress.reporting) {
    if (length(variable.summary$variables[[name]]$invalid.blood.pressure.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.blood.pressure.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      cat(knitr::kable(df, caption = "Values that were not consistent with blood pressure measurement format.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
    } else {
      cat("\n\nAll values consistent with blood pressure format or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.numeric.entries) & !suppress.reporting) {
    if (length(variable.summary$variables[[name]]$invalid.numeric.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.numeric.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      cat(knitr::kable(df, caption = "Values that were not consistent with numeric format.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
    } else {
      cat("\n\nAll values consistent with numeric format or missing data.\n\n")
    }
  }
  ## factors
  ## give ancestry factor variable special treatment
  if (!is.null(variable.summary$variables[[name]]$params$subject_ancestry) & !suppress.reporting) {
    ## instead of reporting failed conversions specifically,
    ## report a table of all imperfect matches to the reference ancestry labels,
    ## and track the outcomes for all of them, even the ones that were eventually
    ## called. this behavior may be updated later once this method has been
    ## improved
    df <- data.frame(
      variable.summary$variables[[name]]$ancestry.conversion.before,
      variable.summary$variables[[name]]$ancestry.conversion.after,
      variable.summary$variables[[name]]$ancestry.reasoning,
      variable.summary$variables[[name]]$ancestry.best.match,
      round(variable.summary$variables[[name]]$ancestry.best.value, 2),
      variable.summary$variables[[name]]$ancestry.second.match,
      round(variable.summary$variables[[name]]$ancestry.second.value, 2)
    )
    colnames(df) <- c(
      "Input",
      "Output",
      "Reasoning",
      "Best Match",
      "Best Score",
      "Second Match",
      "Second Score"
    )
    df$Count <- rep(0, nrow(df))
    for (query in unique(df[, 1])) {
      df$Count[df[, 1] == query] <- length(which(df[, 1] == query))
    }

    ## clean up table: for large datasets, this gets unwieldy
    ## first remove duplicate queries, as the resolution is always the same
    df <- df[!duplicated(df[, 1]), ]
    ## then sort first by reasoning, then by output, then by query
    df <- df[order(df[, 3], df[, 2], df[, 1]), ]
    rownames(df) <- NULL
    cat(knitr::kable(df, caption = "Handling of all partial match self-reported ancestries.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
  } else if (!is.null(variable.summary$variables[[name]]$invalid.factor.entries) & !suppress.reporting) {
    ## other things that are factors
    if (length(variable.summary$variables[[name]]$invalid.factor.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.factor.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      cat(knitr::kable(df, caption = "Values that were not consistent with categorical format.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
    } else {
      cat("\n\nAll values consistent with categorical format or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$invalid.date.entries) & !suppress.reporting) {
    if (length(variable.summary$variables[[name]]$invalid.date.entries) > 0) {
      df <- data.frame(table(variable.summary$variables[[name]]$invalid.date.entries, useNA = "ifany"))
      rownames(df) <- NULL
      colnames(df) <- c(name, "Count")
      df[, 1] <- stringr::str_replace(df[, 1], "^( *)([\\+\\*])", "\\1\\\\\\2")
      cat(knitr::kable(df, caption = "Values that were not consistent with date (year only) format.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
    } else {
      cat("\n\nAll values consistent with date format (year only) or missing data.\n\n")
    }
  }
  if (!is.null(variable.summary$variables[[name]]$unicode.entries) & !suppress.reporting) {
    unicode.df <- data.frame(
      names(variable.summary$variables[[name]]$unicode.entries),
      as.vector(variable.summary$variables[[name]]$unicode.entries)
    )
    rownames(unicode.df) <- NULL
    colnames(unicode.df) <- c("Unicode String", "Observations")
    cat(knitr::kable(unicode.df, caption = "String entries containing unresolved Unicode characters.") %>% kableExtra::kable_styling("condensed", position = "left", full_width = FALSE))
  }
  if (!is.null(variable.summary$variables[[name]]$params$dependencies) & !suppress.reporting) {
    cat("\n\n#### Dependency tracking\n\n")
    dependency.names <- c()
    dependency.conditions <- c()
    dependency.results <- c()
    dependencies <- variable.summary$variables[[name]]$params$dependencies
    for (dependency.index in names(dependencies)) {
      dependency.names <- c(dependency.names, dependencies[[dependency.index]]$name)
      dependency.conditions <- c(dependency.conditions, dependencies[[dependency.index]]$condition)
      dependency.result <- variable.summary$variables[[name]]$dependency.results[[dependency.index]]
      if (length(dependency.result) == 0) {
        dependency.result <- "all subjects pass"
      } else if (length(dependency.result) > 1) {
        dependency.result <- paste(sort(dependency.result), collapse = ", ")
      }
      dependency.results <- c(dependency.results, dependency.result)


      ## allow table_comparisons for simple contingency tables between this and other variables
      if (!is.null(dependencies[[dependency.index]]$table_comparisons)) {
        for (table.target in dependencies[[dependency.index]]$table_comparisons) {
          stopifnot(table.target %in% colnames(phenotype.data))
          comparison.variable.pretty.name <- variable.summary$variables[[table.target]]$original.name
          if (!is.null(variable.summary$variables[[table.target]]$params$canonical_name)) {
            comparison.variable.pretty.name <- paste(comparison.variable.pretty.name,
              " (",
              variable.summary$variables[[table.target]]$params$canonical_name,
              ")",
              sep = ""
            )
          }
          table.data <- table(
            phenotype.data[, table.target],
            phenotype.data[, name],
            useNA = "ifany"
          )
          cat(knitr::kable(table.data,
            caption = paste("Contingency table for ",
              table.target,
              " (",
              comparison.variable.pretty.name,
              ") [rows] versus ",
              name,
              " [columns]",
              sep = ""
            )
          ) %>% kableExtra::kable_styling("condensed"))
        }
      }
    }
    dependency.df <- data.frame(
      Name = dependency.names,
      Condition = dependency.conditions,
      Count = sapply(strsplit(dependency.results, ","), function(i) {
        ifelse(identical(i, "all subjects pass"), 0, length(i))
      }),
      Result = dependency.results
    )
    rownames(dependency.df) <- NULL
    cat(knitr::kable(dependency.df,
      caption = "Results of cross-variable dependency tests."
    ) %>% kableExtra::kable_styling("condensed"))
  }

  cat("\n***\n<br>\n")
}
```

***
<br>

#### Session Information

<br>

The following summarizes the loaded R configuration for the run that created this report.

```{r session.info, eval=TRUE, echo=TRUE}
sessionInfo()
```
